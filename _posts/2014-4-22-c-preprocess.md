---
date: 2014-4-22 12:11:30+00:00
layout: post
title: c语言预处理指令小结
thread: 57
categories: c++
tags: c++
---

编译一个C程序有多个步骤，其中第一个步骤是预处理阶段。C预处理器在源代码编译之前对其进行一些文本性质的操作，如删除注释、插入被#include包含的文件的内容、定义和替换有#define定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译。

C预处理器最基本的指令有四个：

(1)#include 从其他文件里复制源程序正文；

(2)#define 定义宏（有参数的或没有参数的）；

(3)#ifdef 根据某个条件确定是否应该包括一些代码行；

(4)#progma 以某种与实现有关的方式影响编译过程。

### #include ###

替换执行的规则：预处理器删除这条指令，用包含文件的内容取代之；若一个头文件被包含在10个源文件中，它实际上被编译了10次。

(1)函数库文件包含 #include<filename>

函数库文件包含只会在标准位置（如在unix系统上的C编译器在/user/include目录查找）查找函数库文件。

(2)本地文件包含 #include "filename"

本地文件包含首先会在源文件所在的当前目录进行查找，若该头文件未找到，则在标准位置查找本地头文件。

注：#include包含若使用“绝对路径目录”，则正常的目录查找会被跳过，只在指定的目录查找。

### #define ###

定义： `#define name stuff`,预处理器会把name替换为stuff。其中，stuff可以为任何文本，如字面值常量、函数等。

用`#undef name`指令移除一个宏定义。

####宏####

在#define中，把参数替换到文本中，这种实现通常称为定义宏，如`#define SQUARE(x) (x*x)`。

注：(1)宏定义没有分号结尾；(2)所有用于对数值表达式求值的宏定义都应加上括号；(3)宏参数和#define定义可以包含其他#define定义的符号；(4)宏不可以出现递归。

####宏和函数的不同之处####

(1)参数类型。宏与类型无关，可用于任何参数类型；函数参数与类型有关。

(2)参数求值出现副作用。参数每次用于宏定义时，它们都会重新求值，由于多次求值，具有副作用（如i++）的参数可能会产生不良后果；  函数参数只在函数调用时求值一次，多次使用参数不会导致多种求值过程。

(3)操作符优先级。 所有用于对数值表达式求值的宏定义都应加上括号；

(4)执行速度。 函数存在调用和返回的额外开销。宏执行速度更快；

(5)代码长度。 每次使用，宏代码都会被插入到程序中。而函数代码只会出现在同一个地方。

###条件编译###

使用条件编译，可以选择代码的一部分是被正常编译还是完全忽视。

(1)#if 如果给定条件为真，则编译下面代码

(2)#ifdef 如果宏已经定义，则编译下面代码

(3)#ifndef 如果宏没有定义，则编译下面代码

(4)#elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码

(5)#endif 结束一个#if……#else条件编译块

(6)#error 停止编译并显示错误信息


	#if constant-expression
		statements
	#elif constant-expression
		statements
	#else 
		statements
	#endif

### #pragma ###

该指令的作用是对每个编译器给出了一个方法,在保持与C和C++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的（不可移植）。

其格式为：`#pragma para` 其中para为参数。

（1） #pragma message能够在编译信息输出窗口中输出相应的信息

（2） #pragma code_seg能够设置程序中函数代码存放的代码段,开发驱动程序的时会用到

（3） #pragma  once 若用在头文件的最开始处就能够保证头文件被编译一次

（4） #pragma  hdrstop表示预编译头文件到此为止

（5） #pragma  resource "*.dfm"表示把*.dfm文件中的资源加入工程

（6） #pragma warning允许有选择性的修改编译器的警告消息的行为

（7） #pragma comment将一个注释记录放入一个对象文件或可执行文件中

（8） #pragma data_seg建立一个新的数据段并定义共享数据（应用1：在DLL中定义一个共享的，有名字的数据段；应用2： data_seg控制应用程序的启动次数）


#### #pragma once与#ifndef的区别 ####

 	方式一：
    #ifndef __SOMEFILE_H__
    #define __SOMEFILE_H__
    ... ... // 一些声明语句
    #endif

    方式二：

    #pragma once
    ... ... // 一些声明语句

(1) #pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。

(2) #ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况.

参考：[#pragma用法详解](http://blog.csdn.net/gueter/article/details/2234072)  ；[#pragma once与 #ifndef的区别](http://www.cppblog.com/szhoftuncun/archive/2007/10/28/35356.html)
