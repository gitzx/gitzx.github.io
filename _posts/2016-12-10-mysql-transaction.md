---
date: 2016-12-10 10:35:30+00:00
layout: post
title: MySQL事务和锁
thread: 169
categories: database 
tags: database 

---

事务是用户定义的一个数据库操作序列，这些操作要么全部执行，要么全部不执行。事务一般是由事务日志实现的。

### 事务ACID特性 ###

事务具备ACID四个特点：

1. 原子性(Automicity)：整个事务是不可分割的工作单位；

2. 一致性(Consistency)：事务不能破坏关系数据的完整性和业务逻辑的一致性。数据总是从一个一致性的状态转换到另一个一致性的状态。一致性状态是指数据库满足数据的完整性约束（实体完整性约束，参照完整性约束，用户自定义完整性约束）

3. 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不影响其他事务的执行。

4. 持久性(Durability)：已提交事务对数据的修改永久保存在数据库中。

### 事务隔离级别 ###

事务隔离(Isolation Level)：事务在执行过程中是否能够看见其他并发事务对数据的修改。

四种隔离级别：

1. 读取未提交内容(Read Uncommitted)：最低的隔离级别。所有事务都可以读取未提交事务的执行结果，造成“脏读”。实际很少应用；

2. 读取提交内容（Read Committed）:大多数数据库系统默认的隔离级别（但不是MySQL默认）。一个事务从开始到提交前，所做的任何数据改变都是不可变的。一个事务开始时，只能“看到”已经提交的事务作出的改变。这种级别是不可重复读的，意味着用户运行同一条语句两次，看到的结果是不同的。

3. 可重复读(Repeatable Read)：MySQL默认的隔离级别，确保同一个事务的多个实例在并发读取数据的时候，会看到同样的数据行。但是该隔离界别会导致“幻读”，幻读是指用户读取某一个范围的数据行时，另一个事务又在该范围插入了新行，当用户再读取该范围的时候，会发现有新的“幻影”行。InnoDB通过多版本并发控制机制（MVCC）解决的幻读的问题。

4. 可串行化(Serializable)：最高的隔离级别。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。在这个级别，每个事务都会在每个在读的数据行加锁，导致大量锁竞争和超时现象。

### 锁类型 ###

1. 读锁(共享锁)：支持并发读，写操作被锁。

2. 写锁(独占锁)：上锁期间其他线程不能读表或写表。阻塞其他读锁或写锁，独占资源，在给定的时间内只允许一个用户写入。

	（1）悲观锁：悲观锁是指假设并发更新冲突会发生，所以不管冲突是否真的发生，都会使用锁机制。悲观锁会完成以下功能：锁住读取的记录，防止其它事务读取和更新这些记录。其它事务会一直阻塞，直到这个事务结束.

	（2）乐观锁：乐观锁不会锁住任何东西，也就是说，它不依赖数据库的事务机制，乐观锁完全是应用系统层面的东西。

	如果使用乐观锁，那么数据库就必须加版本字段，否则就只能比较所有字段，但因为浮点类型不能比较，所以实际上没有版本字段是不可行的。

3. 更新锁： 共享锁和更新锁的结合。更新锁意味着在做一个更新时，一个共享锁在扫描完成符合条件的数据后可能会转化成排他锁。
 
### 锁粒度(Lock Granularity)和优缺点 ###

锁粒度是指加锁对象资源的大小。锁粒度的大小影响系统的并发性和系统开销，锁粒度越小，并发性越高，但系统加锁的开销也越大。反之锁粒度越大，并发性越低。

锁粒度可以分为：

1. 表锁(table locks)： 在整张表上加锁。

2. 行锁(row locks)：在表中的一行或者多行数据记录上加锁；InnoDB支持，MyISAM不支持（InnoDB与MyISAM区别之一）

3. 页锁(page locks)：目前只有BDB存储引擎上使用。

4. 元数据锁(Metadata locks)：MySQL5.5中引入，应用在表的metadata上。当一个线程使用表的时候，将会锁定整张表的metadata信息，不允许其他线程修改表结构。

### 冲突问题 ###

1. 脏读： 某个事务读取的数据是另一个事务正在处理的数据。而另一个事务可能会回滚，造成第一个事务读取的数据是错误的。

2. 不可重复读：在一个事务里两次读入数据，但另一个事务已经更改了第一个事务涉及到的数据，造成第一个事务读入旧数据。

3. 幻读： 幻读是指当事务不是独立执行时发生的一种现象。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

4. 更新丢失：多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失。


### 隔离级别和锁的区别 ###

隔离级别和锁之间没有任何关系。

1. 隔离是事务特性，由存储引擎决定，事务隔离性进一步确保了在多线程并发环境下数据的安全访问，直接决定事务中sql修改的数据在提交之前是否对其他事务可见。

2. 加锁和解锁：当开始执行sql语句时，将会对一些数据进行加锁，如表、某些行、metadata信息等；当sql执行完成，将会解锁，其他线程就可以开始申请使用资源。

### 事务和锁的简单栗子 ###

事务实现：

	START TRANSACTION;
	SELECT * FROM students WHERE id = 010;
	UPDATE students SET score = 100 WHERE id = 010;
	COMMIT;

利用锁实现上述事务功能：

	LOCK TABLE students WHERE 
	SELECT * FROM students WHERE ID = 010;
	UPDATE students SET score = 100 WHERE id = 010;
	UNLOCK students;


参考： [事务隔离](https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2)