---
date: 2016-3-10 8:12:30+00:00
layout: post
title: 设计模式概述
thread: 100
categories: design_pattern
tags: design_pattern
---

设计模式是指对软件设计上普遍存在反复出现的各种问题，所提出的解决方案。学习了和在程序中有意无意使用设计模式了多次，这次系统的总结记录下。

###设计模式的六大原则###

 1. 开闭原则(Open close principle)：对扩展开放，对修改关闭；

 2. 里氏替换原则(Liskov substitution principle)：任何基类可以出现的地方，子类一定可以出现。 里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

 3. 依赖倒转原则：针对接口编程，而不是针对实现编程；

 4. 接口隔离原则：使用多个隔离的接口，好于使用单个接口。

 5. 迪米特法则(最小知道原则)：一个实体应尽量少的与其他实体之间发生相互作用，使系统功能模块相对独立。

 6. 合成复用原则： 多用组合，少用继承。


###设计模式分类###

《设计模式》介绍了23中设计模式，把设计模式分为三类：

 1. 创建型模式：对类的实例化过程进行了抽象，隐藏了类的实例化和创建细节。

 2. 结构型模式：分为类结构类型模式和对象结构类型模式。类结构类型模式关心类的组合，将多个类组合成一个大类；对象结构类型关心类和对象的组合，通过关联关系在一个类中定义另一个类的实例对象。大部分结构类型都是对象结构类型。

 3. 行为型模式：对不同对象之间划分责任和算法的抽象化。可以分为类行为型模式和对象行为型模式。类行为型模式主要通过多态方式来分配父类和子类的职责；对象行为型模式主要通过对象关联等方式来分配两个或多个类的职责。大部分行为型设计模式都属于对象行为型设计模式。


###创建型模式###

创建型模式有5种：

 1. 单例模式：确保类只有一个实例，且自行实例化并向整个系统提供这个实例；
 
 2. 工厂模式：定义一个创造对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。

 3. 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，且无需指定它们的具体类。

 4. 建造者模式：将一个复杂对象的构建和它的表表示分离，使得同样的构建过程可以创建不同的表上。

 5. 原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型来创建新的对象。


###结构型模式###

 1. 适配器模式：将一个类的接口转换成用户期待的另一个类的接口，使得因接口不兼容而不能一起工作的两个类能一起工作。

 2. 桥接模式：把抽象部分和实现部分分离，使它们都可以独立的变化。

 3. 装饰模式：动态的往一个类中添加新的行为。

 4. 组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

 5. 外观模式：为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。

 6. 代理模式：为其他对象提供一种代理以控制整个对象的访问。

 7. 享元模式：通过共享技术以便有效的支持大量细粒度对象的复用。

###行为型模式###

 1. 模板方法模式：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

 2. 命令模式：把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。

 3. 迭代器模式：提供一种方法访问一个容器对象中的各个元素，而不需暴露该对象的内部细节。

 4. 观察者模式：定义了一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态上发生改变时，会通知所有观察者对象，使它们能自动更新自己。

 5. 中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式的相互引用，从而使其耦合松散，且可以独立的改变它们之间的交互。

 6. 状态模式：允许一个对象在其内部状态改变时改变它的行为，看起来就像是改变了它的类一样。

 7. 策略模式：定义了一系列的算法，把每个算法封装起来，且使它们可以相互替换。使得算法可以在不影响客户端的情况下发生变化。

 8. 责任链模式：将多个对象连成一个链，沿着这条链传递该请求，直到有一个对象处理它为止。

 9. 访问者模式： 封装一些作用于某些数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。

 10. 备忘录模式：在不破坏封闭环境的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态。

 11. 解释器模式：给定一门语言，定义它的方法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

