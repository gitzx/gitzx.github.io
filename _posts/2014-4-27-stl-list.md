---
date: 2014-4-27 11:01:30+00:00
layout: post
title: c++ STL之list
thread: 60
categories: c++
tags: c++
---

STL中list是一个双向链表(区间是“前闭后开”)，提供的迭代器是双向存取迭代器(Bidirectional Iterators).性质有：

(1)list节点在存储空间不是连续存在的；vector的元素是连续存储的；

(2)list对于任何位置的插入和删除是常数时间；而vector不是；

(3)list的插入、删除和拼接操作只会使“指向部分元素”的迭代器失效；而在vector中会使全部迭代器失效。


###list的节点###

	{% highlight C++ %}
	template <class T>
	struct _list_node{
		typedef void* void_pointer;
		void_pointer prev;
		void_pointer next;
		T data;
	}
	{% endhighlight %}
	
###list的数据结构###

	{% highlight C++ %}
	template <class T, class ALloc=alloc>
	class list{
	procted:
		typedef _list_node<T> list_node;
	public:
		typedef list_node* link_type;
	protected:
		link_type node;
	}

	iterator begin(){
		return (link_type) ((*node).next);
	}
	iterator end(){
		return node;
	}
	bool empty() const{
		return node->next==node;	
	}
	size_type size() const{
		size_type result=0;
		distance(begin(),end(),result);
		return result;
	}
	reference front(){
		return *begin();
	}
	reference back(){
		return *(--end());
	}
	{% endhighlight %}
	
###list的元素操作###

(1)push_front、push_back、pop_front、pop_back

	{% highlight C++ %}
	void push_front(const T& x){
		insert(begin(),x);
	}
	void push_back(const T& x){
		insert(end(),x);
	}
	void pop_front(){
		erase(begin());
	}
	void pop_back(){
		iterator tmp=end();
		erase(--tmp);
	}
	{% endhighlight %}
	
(2)erase、clear、remove

	{% highlight C++ %}
	//移除迭代器position所指节点
	iterator erase(iterator position){
		link_type next_node=link_type(position.node->next);
		link_type prev_node=link_type(position.node->prev);
		prev_node->next=next_node;
		next_node->prev=prev_node;
		destroy_node(position.node);
		return iterator(next_node);
	}
	//清除链表所有节点
	template <class T, class Alloc>
	void list<T, Alloc>::clear(){
		link_type cur=(link_type)node->next;
		while(cur!=node){
			link_type tmp=cur;
			cur = (link_type)cur->next;
			destroy_node(tmp);
		}
		node->next=node;
		node->prev=node;
	}
	//将数值未value的所有元素删除
	template <class T, class Alloc>
	void list<T,Alloc>::remove(const T& value){
		iterator first=begin();
		iterator last=end();
		while(first!=end){
			iterator next=first;
			++next;
			if(*first==value)
				erase(first);
			first=next;
		}
	}
	{% endhighlight %}
	
(3)unique(连续而相同的元素，移除剩一个)

	{% highlight C++ %}
	//移除数值相同的连续元素
	template <class T, class Alloc>
	void list<T, Alloc>::unique(){
		iterator first=begin();
		iterator last=end();
		if(first==next) return;
		iterator next=first;
		while(++next!=last){
			if(*first==*next){
				erase(next);
			}else{
				first=next;
			}
			next=first;
		}
	}
	{% endhighlight %}
	
(4)transfer（迁移操作）

(5)reverse

(6)sort

(7)splice