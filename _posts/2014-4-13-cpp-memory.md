---
date: 2014-4-13 22:17:30+00:00
layout: post
title: c++的内存管理小结
thread: 54
categories: c++
tags: c++
---
###内存分配方式###

(1)从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在整个运行期间都存在。如全局变量、static变量；

(2)在栈上创建：在执行函数时，函数局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放；

(3)从堆上分配（动态内存分配）：程序在运行时用malloc或new申请任意多少的内存，程序员自行决定在何时用free或delete释放内存。

###常见的内存错误###

(1)内存分配未成功，却使用了它：   可用assert(!p)或if(p==NULL)、if(p!=NULL)进行防错处理；

(2)内存分配虽然成功，但尚未初始化就饮用它；

(3)内存分配成功且已经初始化，但操作越过了内存的边界：   例如使用数组时数组下标越界；

(4)忘记释放内存，造成内存泄漏：  动态内存申请和释放，程序中malloc和free、new和delete的次数一定要相等；

(5)释放了内存，却继续使用它：

- 使用free或delete释放内存后，没有将指针设置未NULL，导致产生“野指针”；

- 函数的return语句写错。注意不要返回指向“栈内存”的“指针”或“引用”。（因为该内存在函数体结束时被自动销毁）；

- 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。

###野指针###

####指针的一些特征####

- 指针消亡了，并不表示它所指的内存会自动释放；

- 内存被释放了，并不表示指针会消亡或者成为NULL指针。

####野指针####

"野指针"不是NULL指针，是指向“垃圾”内存的指针。“野指针”产生的原因有：

(1)指针没有被初始化。 任何指针变量在创建时不会自动成为NULL指针，它的缺省值时随机的。指针变量在创建时应当被初始化。

	{% highlight C++ %}
	char *p=NULL;
	char *str=(char *)malloc(100);
	{% endhighlight %}
	

(2)free和delete只是把指针所指向的内存给释放掉了，但并没有把指针本身干掉；

	{% highlight C++ %}
	char *p=(char *)malloc(100);
	strcpy(p, "hello");
	//p所指向的内存被释放了，但p所指的地址不变，
	//只是该地址对应的内存是垃圾，p成了“野指针”
	free(p);
	if(p!=NULL){
		strcpy(p,"world"); //出错
	}
	{% endhighlight %}

(3)指针操作超出了变量的作用范围。

	{% highlight C++ %}
	class a   
	{   
	public:  
		void func(void){ cout << “func of class a” << endl; }  
	};  
	void test(void)  
	{  
		a *p;  
		{  
			a a;  
			p = &a; // 注意 a 的生命期  
		}  
		p->func(); // p是“野指针”  
		} 
	{% endhighlight %}

(4)函数体内的局部变量在函数结束时会自动消亡，例如p时局部的指针变量，函数结束时p消亡了，但它所指向的内存没有被释放。

	{% highlight C++ %}
	void func(){
		char *p=(char *)malloc(100);
	}
	{% endhighlight %}

###malloc/free和new/delete的区别

